## 双指针

因为是排序后的数组，因此，相等的元素总是挨着的

设置两个指针`fast`和`slow`，其中`slow`指向当前数组中不最后一个不重复元素，`fast`指针表示从头到尾遍历数组的游标：

~~~
 slow
  ↓
+---+---+---+---+---+---+---+---+---+---+
| 0 | 0	| 1	| 1	| 1	| 2	| 2	| 3	| 3	| 4	|
+---+---+---+---+---+---+---+---+---+---+
	  ↑
	 fast
	 
	 				⇓
	 				
	 slow
  	  ↓
+---+---+---+---+---+---+---+---+---+---+
| 0 | 1	| 1	| 1	| 1	| 2	| 2	| 3	| 3	| 4	|
+---+---+---+---+---+---+---+---+---+---+
	  	  ↑
	 	 fast
	 	 
	 				⇓
	 				
	 	 slow
  	  	  ↓
+---+---+---+---+---+---+---+---+---+---+
| 0 | 1	| 2	| 1	| 1	| 2	| 2	| 3	| 3	| 4	|
+---+---+---+---+---+---+---+---+---+---+
	  	  			  ↑
	 	 	         fast
	 	 	         
	 				⇓
	 				
	 	 	 slow
  	  	  	  ↓
+---+---+---+---+---+---+---+---+---+---+
| 0 | 1	| 2	| 3	| 1	| 2	| 2	| 3	| 3	| 4	|
+---+---+---+---+---+---+---+---+---+---+
	  	  			  		  ↑
	 	 	         		 fast
	 	 	         		 
	 				⇓
	 				
	 	 		 slow
  	  	  		  ↓
+---+---+---+---+---+---+---+---+---+---+
| 0 | 1	| 2	| 3	| 4	| 2	| 2	| 3	| 3	| 4	|
+---+---+---+---+---+---+---+---+---+---+
	  	  			  				  ↑
	 	 	         				 fast
~~~

### 题解：

~~~go
func removeDuplicates(nums []int) int {
	if len(nums) < 2 {
		return len(nums)
	}
	var slow int
	for i := 1; i < len(nums); i++ {
		if nums[i] != nums[slow] {
			slow++
			nums[slow] = nums[i]
		}
	}
	return slow + 1
}
~~~

