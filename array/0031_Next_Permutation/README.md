## [下一个排列](https://leetcode-cn.com/problems/next-permutation)

### 题目

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。

~~~
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
~~~

### 解法一

> 字典序
>
> ​	给定多个字符，可以按照任意顺序进行排列，所有排列称为全排列。
>
> ​	每一种排列对应一个字符串，如果这些字符串按照字符串大小的顺序进行排序，那么就这种排序是基于字典序的全排列。
>
> ​	 比如给定1，2，3，则他们基于字典序的全排列为：
>
> ​	123> 132 > 213 >231 > 312 > 321
>
> 结合一个现实的应用：
>
> ​	可以将已有排列组合成一串数字，下一个排列的数字要比上一个排列的数字大

+ 找规律

  以序列`1, 5, 8, 4, 7, 6, 5, 3, 1`为例：

  如果存在下一个排列，则原始排列中必然存在升序排列，才能满足下一个排列中必然出现新的降序排列

  因此可以认为我们需要在原始排列中寻找排列顺序变更的点，即原始序列由升序转向降序的数字

  由于需要寻找的是下一个排列，即上一个排列合成的数字要比下一个排列合成的数字小，因此我们选定从右向左寻找变更点

+ 算法步骤：

  + 从右向左寻找第一组长度为2的降序数组:

  ~~~
  1, 5, 8, [4, 7], 6, 5, 3, 1
  ~~~

  + 选定需要被提换的数字为`4`，从右向左寻找第一个比`4`大的数字，即`5`

  ~~~
  				  *
  1, 5, 8, 4, 7, 6, 5, 3, 1
           ^
  ~~~

  +  将`5`与`4`调换位置

  ~~~
                    *
  1, 5, 8, 5, 7, 6, 4, 3, 1
           ^
  ~~~

  + 换位后，将`5`后面的数组做升序处理

  ~~~
  1, 5, 8, 5, 1, 3, 4, 6, 7
  ~~~

### [解法二](<https://github.com/aQuaYi/LeetCode-in-Go/tree/master/Algorithms/0031.next-permutation>)

​	1　　2　　7　　4　　3　　1

​	下一个排列为：

​	1　　3　　1　　2　　4　　7

​	那么是如何得到的呢，步骤如下：

​	从后往前，找到最长的降序排列

​	1　　2　　`7　　4　　3　　1`

​	把这个降序排列，转换成升序排列

​	1　　2　　`1　　3　　4　　7`

​	把序列前的元素，与序列中，第一个大于他的元素互换。

​	1　　`3`　　1　　`2`　　4　　7

